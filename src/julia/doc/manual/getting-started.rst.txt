== .. _man-getting-started:
== 
== *****************
++ 시작하기
--  Getting Started
== *****************
== 
++ 줄리아의 설치는 어렵지 않다.  미리 컴파일된 실행파일을 이용하거나,
++ 아니면 소스로부터 직접 컴파일하는 두가지 방법이 존재한다.
++ `http://julialang.org/downloads/ <http://julialang.org/downloads/>`_ 에서
++ 알려주는 방법에 따라 Julia를 다운로드하고 설치하면 된다.
-- Julia installation is straightforward, whether using precompiled
-- binaries or compiling from source. Download and install Julia by
-- following the instructions at
-- `http://julialang.org/downloads/ <http://julialang.org/downloads/>`_.
==
++ Julia를 처음 접할 때는 대화형 실행 환경을 통해서 시작하는 것이
++ 가장 쉽게 Julia를 익힐 수 있는 방법이다.
++ 대화형 실행 환경은 단순히 Julia 실행파일을 더블 클릭하거나, 명령창에서
++ ``julia`` 명령어를 입력하여 실행할 수 있다.
-- The easiest way to learn and experiment with Julia is by starting an
-- interactive session (also known as a read-eval-print loop or "repl")
-- by double-clicking the Julia executable or running ``julia`` from the
-- command line::
== 
++ .. code-block:: julia
++
==     $ julia
==                    _
==        _       _ _(_)_     |  A fresh approach to technical computing
==       (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
==        _ _   _| |_  __ _   |  Type "help()" to list help topics
==       | | | | | | |/ _` |  |
==       | | |_| | | | (_| |  |  Version 0.3.0-prerelease+3690 (2014-06-16 05:11 UTC)
==      _/ |\__'_|_|_|\__'_|  |  Commit 1b73f04* (0 days old master)
==     |__/                   |  x86_64-apple-darwin13.1.0
== 
==     julia> 1 + 2
==     3
== 
==     julia> ans
==     3
== 
++ 대화형 실행 환경을 종료하기 위해서는 ``^D`` 를 입력하거나
++ (컨트롤 키와 ``d`` 키를 ++ 함께 누른다.)
++ ``quit()`` 를 대화형 실행 환경 입력창에 타이핑한다.
++ 대화형 실행 환경을 실행하면, 위와 같이 ``julia`` 배너가 보여지고,
++ 커서창이 사용자의 입력을 기다리며 깜빡이고 있다. 사용자가
++ ``1 + 2`` 와 같은 표현식을 입력한 뒤, 엔터 버튼을 누르는 순간,
++ Julia는 표현식을 평가하고 그 결과를 보여준다.
++ 만약 사용자가 입력한 표현식이 세미콜론(;)으로 끝난다면,
++ 대화형 실행 환경은 결과를 바로 보여주지 않는다.
++ 대신에 ``ans`` 라는 변수가 결과를 보여주든 보여주지 않든
++ 가장 마지막으로 계산된 표현식의 결과를 저장하고 있다.
++ ``ans`` 변수는 대화형 실행 환경에서만 존재하며, 다른 방식으로 동작하는
++ Julia 코드 상에서는 나타나지 않는다.
-- To exit the interactive session, type ``^D`` — the control key
-- together with the ``d`` key or type ``quit()``. When run in interactive
-- mode, ``julia`` displays a banner and prompts the user for input. Once
-- the user has entered a complete expression, such as ``1 + 2``, and
-- hits enter, the interactive session evaluates the expression and shows
-- its value. If an expression is entered into an interactive session
-- with a trailing semicolon, its value is not shown. The variable
-- ``ans`` is bound to the value of the last evaluated expression whether
-- it is shown or not. The ``ans`` variable is only bound in interactive
-- sessions, not when Julia code is run in other ways.
==
++ ``file.ji`` 라는 소스 파일에 저장되어 있는 표현식을 계산하기 위해서는,
++ ``include("file.ji")`` 와 같이 입력한다.
-- To evaluate expressions written in a source file ``file.jl``, write
-- ``include("file.jl")``.
==
++ 대화형 실행 환경을 이용하지 않고
++ 파일에 저장되어 있는 소스 코드를 실행하기 위해서는,
++ 소스 코드 파일 이름을 julia 명령어의 첫번째 매개 변수로 넣어서 실행한다.
-- To run code in a file non-interactively, you can give it as the first
-- argument to the julia command::
==
++ .. code-block:: shell
++
==     $ julia script.jl arg1 arg2...
==
++ 예제와 같이 julia 실행 명령 뒤에 오는 매개변수들은
++ 전역 상수 ``ARGS`` 라고 불리우는
++ ``script.ji`` 프로그램의 명령줄 인자로 작동한다.
++ ``ARGS`` 는 이 뿐만이 아니라
++ ``-e`` 옵션을 통해서 julia 스크립트를 실행할 때도 설정할 수 있다.
++ (아래의 ``julia`` 도움말을 보도록 하자.)
++ 예를 들어, 단순히 스크립트에 주어진 명령줄 인자를 출력할 때는
++ 다음과 같이 입력하면 된다.
-- As the example implies, the following command-line arguments to julia
-- are taken as command-line arguments to the program ``script.jl``, passed
-- in the global constant ``ARGS``. ``ARGS`` is also set when script code
-- is given using the ``-e`` option on the command line (see the ``julia``
-- help output below). For example, to just print the arguments given to a
-- script, you could do this::
==
++ .. code-block:: shell
++
==     $ julia -e 'for x in ARGS; println(x); end' foo bar
==     foo
==     bar
==
++ 아니면 저 코드를 스크립트 파일에 넣고 실행시켜도 가능하다.
-- Or you could put that code into a script and run it::
==
++ .. code-block:: shell
++
==     $ echo 'for x in ARGS; println(x); end' > script.jl
==     $ julia script.jl foo bar
==     foo
==     bar
==
++ Julia는 ``-p`` 옵션이나 ``--machinefile`` 옵션을 이용하여
++ 병렬 환경에서 실행시킬 수 있다.
++ ``-p n`` 옵션은 n개의 worker 프로세스를 생성하지만,
++ ``--machinefile file`` 옵션은 file의 각 행에 지정된 노드마다
++ worker를 생성한다.
++ ``file`` 에 지정된 노드(machine)들은 ``ssh`` 로그인을 통해
++ 패스워드가 필요없이 실행할 수 있어야 하며,
++ Julia는 현재 호스트와 같은 경로에 설치가 되어 있어야 한다.
++ ``file`` 에 작성되는 노드는
++ ``[count*][user@]host[:port] [bind_addr[:port]]``
++ 와 같은 형식으로 작성한다.
++ ``user`` 는 현재 user id를 나타내고, ``port`` 는 기본 ssh port,
++ ``count`` 는 각 노드당 생성하는 worker의 개수 (기본값 : 1)
++ ``bin-to bind_addr[:port]`` 은 선택적인 옵션으로
++ 다른 worker들이 현재의 worker로 연결하기 위해 필요한
++ 특정 ip 주소와 포트를 지정한다.
-- Julia can be started in parallel mode with either the ``-p`` or the
-- ``--machinefile`` options. ``-p n`` will launch an additional ``n`` worker
-- processes, while ``--machinefile file`` will launch a worker for each line in
-- file ``file``. The machines defined in ``file`` must be accessible via a
-- passwordless ``ssh`` login, with Julia installed at the same location as the
-- current host. Each machine definition takes the form
-- ``[count*][user@]host[:port] [bind_addr[:port]]`` . ``user`` defaults to current user,
-- ``port`` to the standard ssh port. ``count`` is the number of workers to spawn
-- on the node, and defaults to 1. The optional ``bind-to bind_addr[:port]``
-- specifies the ip-address and port that other workers should use to
-- connect to this worker.
==
==
++ 만약 julia가 실행할 때마다 실행되는 코드가 있다면,
++ 그 코드를 ``~/.juliarc.ji`` 에 넣으면 된다.
-- If you have code that you want executed whenever julia is run, you can
-- put it in ``~/.juliarc.jl``:
-- 
-- .. raw:: latex
-- 
--     \begin{CJK*}{UTF8}{mj}
-- 
-- ::
++ 
++ .. code-block:: shell
== 
==     $ echo 'println("Greetings! 你好! 안녕하세요?")' > ~/.juliarc.jl
==     $ julia
==     Greetings! 你好! 안녕하세요?
== 
==     ...
== 
-- .. raw:: latex
-- 
--     \end{CJK*}
== 
++ ``perl`` 이나 ``ruby`` 와 같이, 
++ Julia 코드를 실행하고 옵션을 지정하는 방법은 다음과 같이 여러가지가 있다.
-- There are various ways to run Julia code and provide options, similar to
-- those available for the ``perl`` and ``ruby`` programs::
== 
++ ::
++ 
==     julia [options] [program] [args...]
++      -v, --version             버전 정보를 표시한다.
++      -h, --help                이 메시지를 표시한다.
++      -q, --quiet               시작할 때 배너를 재거한다.
++      -H, --home <dir>          Julia 실행파일의 위치를 지정한다.
++ 
++      -e, --eval <expr>         <expr>를 실행만 한다.
++      -E, --print <expr>        <expr>를 실행하고 표시한다.
++      -P, --post-boot <expr>    <expr>를 실행하되, 대화형 실행환경을 유지한다.
++      -L, --load <file>         <file>을 모든 프로세서에 로드한다.
++      -J, --sysimage <file>     <file>이라는 시스템 이미지 파일을 로드한 뒤 실행한다.
++      -C, --cpu-target <target> <target>까지의 CPU기능만을 사용한다.
++ 
++      -p, --procs {N|auto}      N개의 추가 worker 프로세스를 생성한다.
++                                'auto'는 현재 Julia를 실행하는 컴퓨터의 최대 코어수만큼 worker 프로세스를 생성한다. 
++      --machinefile <file>      <file>에 나열된 호스트에서 worker 프로세스를 생성한다.
++ 
++      -i                        isinteractive() 결과를 강제적으로 true로 만든다.
++      --color={yes|no}          모든 텍스트에 색상을 표시하거나 표시하지 않는다.
++ 
++      --history-file={yes|no}   작업내역을 저장하거나 로드한다.
++      --no-history-file         히스토리 파일을 로드하지 않는다.
++                                (권장되지 않음, --history-file=no을 사용하는 것이 좋다.)
++      --startup-file={yes|no}   ~/.juliarc.jl를 불러온다.
++      -f, --no-startup          ~/.juliarc를 불러오지 않는다.
++                                (권장되지 않음, --startup-file=no를 사용하는 것이 좋다.)
++      -F                        ~/.juliarc를 불러온다.
++                                (권장되지 않음, --startup-file=yes를 사용하는 것이 좋다.)
++ 
++      --compile={yes|no|all}    컴파일러를 활성화거나 비활성화한다. 혹은 전체 컴파일을 요청한다. 
++ 
++      --code-coverage={none|user|all}, --code-coverage
++                                소스 코드 라인의 실행 횟수를 기록한다. (기본값 : 'user')
++ 
++      --track-allocation={none|user|all}, --track-allocation
++                                각 소스 코드 라인에 의해 할당되는 바이트 수를 기록한다.
++ 
++      -O, --optimize
++                                코드 실행시간에 관련된 최적화를 실행한다.
++      --check-bounds={yes|no}   배열의 경계 체크를 항상 생략하거나 실행한다. (변수 선언을 무시)
++      --dump-bitcode={yes|no}   시스템 이미지를 위한 이진코드를 dump한다. (--build 옵션과 함께 쓰인다.)
++      --depwarn={yes|no|error}  문법과 함수에 관련한 deprecation 경고를 활성화하거나 비활성화한다.
++                                ('error'는 경고를 에러로 바꾼다.)
++ 
++      --inline={yes|no}         inlining을 허용할지 결정한다. (@inline로 선언된 함수를 덮어쓴다.)
++      --math-mode={ieee|user}   IEEE 부동소수점 표준을 쓰거나 (변수 선언을 무시),
++                                소스에서 선언된 부동소수점을 따른다.
--      -v, --version             Display version information
--      -h, --help                Print this message
--      -q, --quiet               Quiet startup without banner
--      -H, --home <dir>          Set location of julia executable
-- 
--      -e, --eval <expr>         Evaluate <expr>
--      -E, --print <expr>        Evaluate and show <expr>
--      -P, --post-boot <expr>    Evaluate <expr>, but don't disable interactive mode
--      -L, --load <file>         Load <file> immediately on all processors
--      -J, --sysimage <file>     Start up with the given system image file
--      -C, --cpu-target <target> Limit usage of cpu features up to <target>
-- 
--      -p, --procs {N|auto}      Integer value N launches N additional local worker processes
--                                'auto' launches as many workers as the number of local cores
--      --machinefile <file>      Run processes on hosts listed in <file>
-- 
--      -i                        Force isinteractive() to be true
--      --color={yes|no}          Enable or disable color text
-- 
--      --history-file={yes|no}   Load or save history
--      --no-history-file         Don't load history file (deprecated, use --history-file=no)
--      --startup-file={yes|no}   Load ~/.juliarc.jl
--      -f, --no-startup          Don't load ~/.juliarc   (deprecated, use --startup-file=no)
--      -F                        Load ~/.juliarc         (deprecated, use --startup-file=yes)
-- 
--      --compile={yes|no|all}    Enable or disable compiler, or request exhaustive compilation
-- 
--      --code-coverage={none|user|all}, --code-coverage
--                               Count executions of source lines (omitting setting is equivalent to 'user')
-- 
--     --track-allocation={none|user|all}, --track-allocation
--                               Count bytes allocated by each source line
-- 
--     -O, --optimize
--                               Run time-intensive code optimizations
--     --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)
--     --dump-bitcode={yes|no}   Dump bitcode for the system image (used with --build)
--     --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings ('error' turns warnings into errors)
-- 
--     --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)
--     --math-mode={ieee|user}   Always use IEEE semantics for math (ignoring declarations),
--                               or adhere to declarations in source code
== 
++ 다른 읽을 거리
++ --------------
-- Resources
-- ---------
== 
++ 이 매뉴얼 뿐만 아니라 Julia를 처음 접하는 사용자들에게 도움을 줄 수 있는 다른 문서를 소개한다.
-- In addition to this manual, there are various other resources that may
-- help new users get started with Julia:
== 
== - `Julia and IJulia cheatsheet <http://math.mit.edu/~stevenj/Julia-cheatsheet.pdf>`_
== - `Learn Julia in a few minutes <http://learnxinyminutes.com/docs/julia/>`_
== - `Tutorial for Homer Reid's numerical analysis class <http://homerreid.dyndns.org/teaching/18.330/JuliaProgramming.shtml>`_
== - `An introductory presentation <https://raw.githubusercontent.com/ViralBShah/julia-presentations/master/Fifth-Elephant-2013/Fifth-Elephant-2013.pdf>`_
== - `Videos from the Julia tutorial at MIT <http://julialang.org/blog/2013/03/julia-tutorial-MIT/>`_
== - `Forio Julia Tutorials <http://forio.com/labs/julia-studio/tutorials/>`_
== 
